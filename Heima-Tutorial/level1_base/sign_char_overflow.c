//
// Created by Xin Yuan on 2023/9/20.
//
#include <stdio.h>

/*
 * 演示有符号数、无符号数的加减法
 * char 在C/C++中占用1个字节
 *
 * 关于原码、反码、补码相关的概念与计算方式：
 *      ref https://zhuanlan.zhihu.com/p/99082236
 *      ref https://zhuanlan.zhihu.com/p/215659536
下文解释了”为什么n bit有符号数范围是-2^n ~ 2^n -1？“
例如8bit有符号数：-128 ~ +127，及其原码补码，本文会非常清楚地讲一下这个范围是怎么来的以及它们的原码补码
最高位为符号位，0代表正数，1代表负数，正数原码和补码相同，负数的补码是原码符号位不变其他位取反，再+1，
讲计算规则会一头雾水，用列表的形式给出会清晰很多：

值, 原码(正数补码等于原码)
+127, 0111 1111
+126, 0111 1110
+125, 0111 1101
……
+4, 0000 0100
+3, 0000 0011
+2, 0000 0010
+1, 0000 0001
   0, 0000 0000  （不区分正负）

值，原码，符号位不变各位取反， 然后+1（即补码）
-1, 1000 0001, 1111 1110, 1111 1111
-2, 1000 0010, 1111 1101, 1111 1110
-3, 1000 0011, 1111 1100, 1111 1101
……
-124, 1111 1100, 1000 0011, 1000 0100
-125, 1111 1101, 1000 0010, 1000 0011
-126, 1111 1110, 1000 0001, 1000 0010
-127, 1111 1111, 1000 0000, 1000 0001
-128, 1000 0000, 1111 1111, 1000 0000

（1）-128的原码： 从-127的数据位(第0~6位)+1而来，进位被丢弃
（2）-128符号位不变各位取反，得到1111 1111
（3）然后+1得到补码，数据位+1之后，全变为0，进位被丢弃，注意：进位不加到符号位上。
（4）-128的原码看起来是-0，可以这么不确切地通俗地说：用+0表示0，用-0表示-128。相当于-128的最高位即表示符号位，又表示数据位，大于-128的补码，最高位仅仅表示符号位，不表示数据位
（5）计算机中负数用补码来存，正是因为用补码来存，所以存着的数从-128一直到+127看起来是很有规律的：
-128,                  -127,         -126，      … , -2，                       -1，          0，            +1，         … ,    +126，            +127
1000 0000, 1000 0001, 1000 0010, …,1111 1110, 1111 1111, 0000 0000, 0000 0001, …, 0111 1110, 0111 1111
这样看起来就是直接从1000 0000一直+1（进位加到符号位上），一直加到0111 1111，再加就又变为1000 0000了
之前说的进位不加到符号位上，是我们定义的从原码计算补码的规则，这个规则就是进位不加到符号位上。
这里说的从1000 0000 一直+1并且进位加到符号位上，是说从计算机内部储存数据的方式来看，可以看成是这样的一种形式，并且这种形式很有规律。
有可能在发明之初，就直接让数字从1000 0000到0111 1111排好，然后我们定义前128个数字为-128到-1，后128个数字为0到+127，在这基础上，再发展而来对于符号位，原码，补码的定义。


 * */

int main(){
    unsigned char a = 127;
    unsigned char b = 1;
    unsigned char c = a + b;
    printf("c = %d \n", c);

    // 以下两种方式定义变量相同，如果不指定是否为无符号数，则默认为有符号数
    // 在计算机中基于补码进行加减运算
    // 127的原码、反码、补码依次为（8bit）：0111 1111，0111 1111， 0111 1111
    // 1的原码、反码、补码依次为（8bit）：  0000 0001，0000 0001， 0000 0001
    // 1 + 127 即 0111 1111 + 0000 0001 = 1000 0000（补码）
    // 1000 0000（补码，最高位是符号位，1表示是负数）->（补码-1得到反码，数据位不参与运算）1111 1111（反码）->除符号位外按位取反得到原码 1000 0000（-128）
    signed char a1 = 127;
    signed char b1 = 1;
    signed char c1 = a1 + b1; // -128，补码加法，发生正溢出（由于 a+b>=2**(8-1)，即a+b>=128，因此发生正溢出
    printf("c1 = %d \n", c1);

    char a2 = 127;
    char b2 = 1;
    char c2 = a2 + b2;
    printf("c2 = %d \n", c2);  // -128，补码加法，发生正溢出（由于 a+b>=2**(8-1)，即a+b>=128，因此发生正溢出，0111 1111 + 0000 0001= 1000 0000

    char a21 = 127;
    char b21 = 2;
    char c21 = a21 + b21;
    printf("c21 = %d \n", c21);  // -127，补码加法，发生正溢出（由于 a+b>=2**(8-1)，即a+b>=128，因此发生正溢出，0111 1111 + 0000 0010 = 1000 0001

    char a3 = 127;
    char b3 = 0;
    char c3 = a3 + b3;
    printf("c3 = %d \n", c3);  // 127，补码加法，正常结果  （由于 -2**（8-1） <= a+b<2**（8-1），即 -128<=a+b<128

    char a4 = -127;
    char b4 = -0;
    char c4 = a4 + b4;
    printf("c4 = %d \n", c4);  // -127，补码加法，正常结果  （由于 -2**（8-1） <= a+b<2**（8-1），即 -128<=a+b<128

    char a5 = -127;
    char b5 = -1;
    char c5 = a5 + b5;
    printf("c5 = %d \n", c5);  // -128，补码加法，正常结果  （由于 -2**（8-1） <= a+b<2**（8-1），即 -128<=a+b<128

    char a6 = -127;
    char b6 = -2;
    char c6 = a6 + b6;
    printf("c6 = %d \n", c6);  // 127，补码加法，发生了负溢出  （由于 -2**（8-1） <= a+b<2**（8-1），即 -128<=a+b<128，1000 0001 + 1111 1110 = 1 0111 1111
    return 0;
}